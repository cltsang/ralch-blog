<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Software adventures and thoughts</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://localhost:1313/tags/reflection/</link>
    <language>en-us</language>
    <author>Svett Ralchev</author>
    
    <updated>Sat, 11 Apr 2015 22:11:18 BST</updated>
    
    
    <item>
      <title>Fast run time emitting with dynamic methods in .NET</title>
      <link>http://localhost:1313/2015/04/fast-run-time-emitting-with-dynamic-methods/</link>
      <pubDate>Sat, 11 Apr 2015 22:11:18 BST</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://localhost:1313/2015/04/fast-run-time-emitting-with-dynamic-methods/</guid>
      <description>&lt;p&gt;It was a long time since, I have blogged. Nevertheless, I did not loose the enthusiasm to share the interesting stuff that I face.
As component software developer, you should know how to access the properties of data source, when you create bound able controls (such as list control, combo box control or even grid control).
The performance has always been a issue due to the fact that the control should work with any type of data source (ex. DataSet, DataTable or Entity Objects).
Such requirements cause usage of reflection to access all properties of unknown object type. Therefore, you should use the PropertyInfo or PropertyDescriptor  classes.
The disadvantage of the reflection has been always the performance. However, there is good alterative that can give satisfactory speed and
unlimited power of the reflection. The Dynamic Methods provide lightweight code generation and execution of method at run-time via delegates.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/sfk2s47t.aspx&#34;&gt;Dynamic methods&lt;/a&gt; expand the functionality of the types in the System.Reflection.Emit namespace in several ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They have less overhead, because there is no need to generate dynamic assemblies, modules, and types to contain the methods.&lt;/li&gt;
&lt;li&gt;In long-running applications, they provide better resource utilization because the memory used by method bodies can be reclaimed when the method is no longer needed.&lt;/li&gt;
&lt;li&gt;Given sufficient security permissions, they provide the ability to associate code with an existing assembly or type, and that code can have the same visibility as internal types or private members.&lt;/li&gt;
&lt;li&gt;Given sufficient security permissions, they allow code to skip just-in-time (JIT) visibility checks and access the private and protected data of objects.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Before you define the method body, you should declare the delegate types that you should use to access the properties of the unknown type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected delegate void SetValueHandler(object component, object value);
protected delegate object GetValueHandler(object component);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Implementation of this methods requires Microsoft Intermediate Language (IL):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected virtual GetValueHandler CreateGetValueHandler(PropertyInfo propertyInfo)
{
    MethodInfo getMethodInfo = propertyInfo.GetGetMethod();
    DynamicMethod getMethod = new DynamicMethod(&amp;quot;GetValue&amp;quot;, typeof(object), new Type[] { typeof(object) }, typeof(PropertyAccessor), true);
    ILGenerator ilGenerator = getMethod.GetILGenerator();

    ilGenerator.Emit(OpCodes.Ldarg_0);
    ilGenerator.Emit(OpCodes.Call, getMethodInfo);

    Type returnType = getMethodInfo.ReturnType;

    if (returnType.IsValueType)
    {
        ilGenerator.Emit(OpCodes.Box, returnType);
    }

    ilGenerator.Emit(OpCodes.Ret);

    return getMethod.CreateDelegate(typeof(GetValueHandler)) as GetValueHandler;

}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, the body of the setter method should be created as itâ€™s shown in the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected virtual SetValueHandler CreateSetValueHandler(PropertyInfo propertyInfo)
{
    MethodInfo setMethodInfo = propertyInfo.GetSetMethod(false);
    DynamicMethod setPropertyValue = new DynamicMethod(&amp;quot;SetValue&amp;quot;, typeof(void), new Type[] { typeof(object), typeof(object) }, typeof(PropertyAccessor), true);
    ILGenerator ilGenerator = setPropertyValue.GetILGenerator();

    ilGenerator.Emit(OpCodes.Ldarg_0);
    ilGenerator.Emit(OpCodes.Ldarg_1);

    Type parameterType = setMethodInfo.GetParameters()[0].ParameterType;

    if (parameterType.IsValueType)
    {
        ilGenerator.Emit(OpCodes.Unbox_Any, parameterType);
    }

    ilGenerator.Emit(OpCodes.Call, setMethodInfo);
    ilGenerator.Emit(OpCodes.Ret);

    return setPropertyValue.CreateDelegate(typeof(SetValueHandler)) as SetValueHandler;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have encapsulated the dynamic method accesses in the &lt;code&gt;PropertyAccessor&lt;/code&gt; class, which declaration looks as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class PropertyAccessor
{
    protected delegate void SetValueHandler(object component, object value);
    protected delegate object GetValueHandler(object component);

    private SetValueHandler setValueHandler;
    private GetValueHandler getValueHandler;

    public PropertyAccessor(Type ownerType, string propertyName)
    {
        PropertyInfo propertyInfo = ownerType.GetProperty(propertyName);

        if (propertyInfo.CanRead)
        {
            this.getValueHandler = this.CreateGetValueHandler(propertyInfo);
        }

        if (propertyInfo.CanWrite)
        {
            this.setValueHandler = this.CreateSetValueHandler(propertyInfo);
        }
    }

    public object GetValue(object component)
    {
        if (this.getValueHandler == null)
        {
            throw new InvalidOperationException();
        }

        return this.getValueHandler(component);
    }

    public void SetValue(object component, object value)
    {
        if (this.setValueHandler == null)
        {
            throw new InvalidOperationException();
        }

        this.setValueHandler(component, value);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I measured the performance among the three approaches against 1 000 000 times invocation of the &lt;code&gt;Employee&lt;/code&gt; property:&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;http://localhost:1313/media/dynamic_method_emit_diagram.png&#34; alt=&#34;Dynamic methods performance diagram&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Notice that the direct access approach followed by the Dynamic Methods implementation are the fastest.&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>