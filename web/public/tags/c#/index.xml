<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Software adventures and thoughts</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://localhost:1313/tags/c/</link>
    <language>en-us</language>
    <author>Svett Ralchev</author>
    
    <updated>Sat, 11 Apr 2015 22:11:18 BST</updated>
    
    
    <item>
      <title>Fast run time emitting with dynamic methods in .NET</title>
      <link>http://localhost:1313/2015/04/fast-run-time-emitting-with-dynamic-methods/</link>
      <pubDate>Sat, 11 Apr 2015 22:11:18 BST</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://localhost:1313/2015/04/fast-run-time-emitting-with-dynamic-methods/</guid>
      <description>&lt;p&gt;It was a long time since, I have blogged. Nevertheless, I did not loose the enthusiasm to share the interesting stuff that I face.
As component software developer, you should know how to access the properties of data source, when you create bound able controls (such as list control, combo box control or even grid control).
The performance has always been a issue due to the fact that the control should work with any type of data source (ex. DataSet, DataTable or Entity Objects).
Such requirements cause usage of reflection to access all properties of unknown object type. Therefore, you should use the PropertyInfo or PropertyDescriptor  classes.
The disadvantage of the reflection has been always the performance. However, there is good alterative that can give satisfactory speed and
unlimited power of the reflection. The Dynamic Methods provide lightweight code generation and execution of method at run-time via delegates.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/sfk2s47t.aspx&#34;&gt;Dynamic methods&lt;/a&gt; expand the functionality of the types in the System.Reflection.Emit namespace in several ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They have less overhead, because there is no need to generate dynamic assemblies, modules, and types to contain the methods.&lt;/li&gt;
&lt;li&gt;In long-running applications, they provide better resource utilization because the memory used by method bodies can be reclaimed when the method is no longer needed.&lt;/li&gt;
&lt;li&gt;Given sufficient security permissions, they provide the ability to associate code with an existing assembly or type, and that code can have the same visibility as internal types or private members.&lt;/li&gt;
&lt;li&gt;Given sufficient security permissions, they allow code to skip just-in-time (JIT) visibility checks and access the private and protected data of objects.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Before you define the method body, you should declare the delegate types that you should use to access the properties of the unknown type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected delegate void SetValueHandler(object component, object value);
protected delegate object GetValueHandler(object component);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Implementation of this methods requires Microsoft Intermediate Language (IL):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected virtual GetValueHandler CreateGetValueHandler(PropertyInfo propertyInfo)
{
    MethodInfo getMethodInfo = propertyInfo.GetGetMethod();
    DynamicMethod getMethod = new DynamicMethod(&amp;quot;GetValue&amp;quot;, typeof(object), new Type[] { typeof(object) }, typeof(PropertyAccessor), true);
    ILGenerator ilGenerator = getMethod.GetILGenerator();

    ilGenerator.Emit(OpCodes.Ldarg_0);
    ilGenerator.Emit(OpCodes.Call, getMethodInfo);

    Type returnType = getMethodInfo.ReturnType;

    if (returnType.IsValueType)
    {
        ilGenerator.Emit(OpCodes.Box, returnType);
    }

    ilGenerator.Emit(OpCodes.Ret);

    return getMethod.CreateDelegate(typeof(GetValueHandler)) as GetValueHandler;

}   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also, the body of the setter method should be created as itâ€™s shown in the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protected virtual SetValueHandler CreateSetValueHandler(PropertyInfo propertyInfo)
{
    MethodInfo setMethodInfo = propertyInfo.GetSetMethod(false);
    DynamicMethod setPropertyValue = new DynamicMethod(&amp;quot;SetValue&amp;quot;, typeof(void), new Type[] { typeof(object), typeof(object) }, typeof(PropertyAccessor), true);
    ILGenerator ilGenerator = setPropertyValue.GetILGenerator();

    ilGenerator.Emit(OpCodes.Ldarg_0);
    ilGenerator.Emit(OpCodes.Ldarg_1);

    Type parameterType = setMethodInfo.GetParameters()[0].ParameterType;

    if (parameterType.IsValueType)
    {
        ilGenerator.Emit(OpCodes.Unbox_Any, parameterType);
    }

    ilGenerator.Emit(OpCodes.Call, setMethodInfo);
    ilGenerator.Emit(OpCodes.Ret);

    return setPropertyValue.CreateDelegate(typeof(SetValueHandler)) as SetValueHandler;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have encapsulated the dynamic method accesses in the &lt;code&gt;PropertyAccessor&lt;/code&gt; class, which declaration looks as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class PropertyAccessor
{
    protected delegate void SetValueHandler(object component, object value);
    protected delegate object GetValueHandler(object component);

    private SetValueHandler setValueHandler;
    private GetValueHandler getValueHandler;

    public PropertyAccessor(Type ownerType, string propertyName)
    {
        PropertyInfo propertyInfo = ownerType.GetProperty(propertyName);

        if (propertyInfo.CanRead)
        {
            this.getValueHandler = this.CreateGetValueHandler(propertyInfo);
        }

        if (propertyInfo.CanWrite)
        {
            this.setValueHandler = this.CreateSetValueHandler(propertyInfo);
        }
    }

    public object GetValue(object component)
    {
        if (this.getValueHandler == null)
        {
            throw new InvalidOperationException();
        }

        return this.getValueHandler(component);
    }

    public void SetValue(object component, object value)
    {
        if (this.setValueHandler == null)
        {
            throw new InvalidOperationException();
        }

        this.setValueHandler(component, value);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I measured the performance among the three approaches against 1 000 000 times invocation of the &lt;code&gt;Employee&lt;/code&gt; property:&lt;/p&gt;

&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;http://localhost:1313/media/dynamic_method_emit_diagram.png&#34; alt=&#34;Dynamic methods performance diagram&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Notice that the direct access approach followed by the Dynamic Methods implementation are the fastest.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>LINQ to SQL: Create generic method to load entity by primary key</title>
      <link>http://localhost:1313/2015/04/linq-to-sql-create-generic-method-to-load-entity-by-primary-key/</link>
      <pubDate>Sat, 11 Apr 2015 20:19:59 BST</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://localhost:1313/2015/04/linq-to-sql-create-generic-method-to-load-entity-by-primary-key/</guid>
      <description>

&lt;h1 id=&#34;scenario:1dbf5425e9da49dc7817a5a2949312e5&#34;&gt;Scenario&lt;/h1&gt;

&lt;p&gt;We are implementing our data access layer based on LINQ TO SQL. In the specifications that were created by our software architect is required to have generic method that load from the data base any record into entity object by primary key.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class LINQGateway&amp;lt;TEntity&amp;gt; where TEntity : class
{
    private IDbConnection _DbConnection;
    public LINQGateway(IDbConnection connection)
    {
        this._DbConnection = connection;
    }
    public TEntity GetEntityByPrimaryKey(object pkKey, params object[] pkKeys)
    {
        // TO DO
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;problem:1dbf5425e9da49dc7817a5a2949312e5&#34;&gt;Problem&lt;/h1&gt;

&lt;p&gt;Every table has different primary key (count, name and data type of the primary key columns).&lt;/p&gt;

&lt;h1 id=&#34;algorithm:1dbf5425e9da49dc7817a5a2949312e5&#34;&gt;Algorithm&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;Get tha mapping of the entity type&lt;/li&gt;
&lt;li&gt;Use information for the mapping
2.1 to get the name of the columns
2.2 to get the name of the columns included in the primary key&lt;/li&gt;
&lt;li&gt;Generate the T-SQL Query&lt;/li&gt;
&lt;li&gt;Execute the Query via LINQ Framework to retrive the result as entity object&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;solutions:1dbf5425e9da49dc7817a5a2949312e5&#34;&gt;Solutions&lt;/h1&gt;

&lt;h2 id=&#34;building-t-sql-query:1dbf5425e9da49dc7817a5a2949312e5&#34;&gt;Building T-SQL query&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;TEntity GetEntityByPrimaryKey(object pkKey, params object[] pkKeys)
{
    List&amp;lt;object&amp;gt; primaryKeys = new List&amp;lt;object&amp;gt;();
    primaryKeys.Add(pkKey);
    primaryKeys.AddRange(pkKeys);

    TEntity entity = null;
    Type entityType = typeof(TEntity);

    using (DataContext dataContext = new DataContext(this._DbConnection))
    {
        dataContext.Log = new DebuggerWriter();
        dataContext.ObjectTrackingEnabled = false;

        Table&amp;lt;TEntity&amp;gt; table = dataContext.GetTable&amp;lt;TEntity&amp;gt;();

        MetaType metaEntityType = dataContext.Mapping.GetMetaType(entityType);

        var primaryKeyColumns = from pkColumn in metaEntityType.DataMembers
                                where pkColumn.IsPrimaryKey
                                select pkColumn;

        var columns = from col in metaEntityType.DataMembers
                      where col.IsPersistent &amp;amp;&amp;amp; !col.IsAssociation
                      orderby col.Ordinal
                      select &amp;quot;[t0].[&amp;quot; + col.MappedName + &amp;quot;]&amp;quot;;

        string selectColumns = String.Join(&amp;quot;, &amp;quot;, columns.ToArray());

        int pkColumnsCount = 0;

        if (primaryKeyColumns != null)
            pkColumnsCount = primaryKeyColumns.Count();

        if (pkColumnsCount == 0)
            throw new InvalidOperationException(&amp;quot;Table doesnâ€™t have primary key&amp;quot;);

        if (pkColumnsCount != primaryKeys.Count)
            throw new InvalidOperationException(&amp;quot;Primary key values doesnâ€™t match primary key columns.&amp;quot;);


        string tableName = metaEntityType.Table.TableName;

        if (tableName.Contains(â€˜.â€™))
        {
            string[] splittedTablename = metaEntityType.Table.TableName.Split(â€˜.â€™).Select(p =&amp;gt; &amp;quot;[&amp;quot; + p + &amp;quot;]&amp;quot;).ToArray();
            tableName = String.Join(&amp;quot;.&amp;quot;, splittedTablename);
        }

        StringBuilder builder = new StringBuilder(&amp;quot;SELECT &amp;quot; + selectColumns + Environment.NewLine + &amp;quot;FROM &amp;quot; + tableName + &amp;quot; AS [t0]&amp;quot; + Environment.NewLine + &amp;quot;WHERE &amp;quot;);

        int index = 0;

        foreach (MetaDataMember pkColumn in primaryKeyColumns)
        {
            string columnName = pkColumn.Name;
            string paramID = index.ToString(CultureInfo.InvariantCulture);
            builder.Append(&amp;quot;[t0].[&amp;quot; + columnName + &amp;quot;] = {&amp;quot; + paramID + &amp;quot;}&amp;quot;);

            if (index + 1 != pkColumnsCount)
                builder.Append(&amp;quot; AND &amp;quot;);

            index++;
        }

        string query = builder.ToString();
        entity = dataContext.ExecuteQuery&amp;lt;TEntity&amp;gt;(query, primaryKeys.ToArray()).SingleOrDefault();
    }

    return entity;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dynamic-linq-expression:1dbf5425e9da49dc7817a5a2949312e5&#34;&gt;Dynamic LINQ expression&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;TEntity GetEntityByPrimaryKey(object pkKey, params object[] pkKeys)
{
    List&amp;lt;object&amp;gt; primaryKeys = new List&amp;lt;object&amp;gt;();
    primaryKeys.Add(pkKey);
    primaryKeys.AddRange(pkKeys);
 
    TEntity entity = null;
    Type entityType = typeof(TEntity);
 
    using (DataContext dataContext = new DataContext(this._DbConnection))
    {
        dataContext.Log = new DebuggerWriter();
        dataContext.ObjectTrackingEnabled = false;
 
        Table&amp;lt;TEntity&amp;gt; table = dataContext.GetTable&amp;lt;TEntity&amp;gt;();
 
        MetaType metaEntityType = dataContext.Mapping.GetMetaType(entityType);
 
        var primaryKeyColumns = from pkColumn in metaEntityType.DataMembers
                                where pkColumn.IsPrimaryKey
                                select pkColumn;
 
        int pkColumnsCount = 0;
 
        if (primaryKeyColumns != null)
            pkColumnsCount = primaryKeyColumns.Count();
 
        if (pkColumnsCount == 0)
            throw new InvalidOperationException(&amp;quot;Table doesnâ€™t have primary key&amp;quot;);
 
        if (pkColumnsCount != primaryKeys.Count)
            throw new InvalidOperationException(&amp;quot;Primary key value doesnâ€™t match primary key columns.&amp;quot;);
 
        ParameterExpression paramExpression = Expression.Parameter(entityType, &amp;quot;entity&amp;quot;);
 
        BinaryExpression whereExpression = null;
 
        int index = 0;
 
        foreach (MetaDataMember pkColumn in primaryKeyColumns)
        {
            object value = primaryKeys[index];
            string columnName = pkColumn.Name;
 
            if (value != null &amp;amp;&amp;amp; value.GetType() != pkColumn.Type)
            {
                Type paramType = value.GetType();
                string exceptionMsg = String.Format(&amp;quot;The type â€˜{0}â€™ of parameter â€˜{1}â€™ is different than its column â€˜{2}â€™ type â€˜{3}â€™&amp;quot;, paramType, value, columnName, pkColumn.Type);
                throw new InvalidOperationException(exceptionMsg);
            }
 
            BinaryExpression condition = Expression.Equal(Expression.Property(paramExpression, columnName), Expression.Constant(value));
 
            if (whereExpression != null)
                whereExpression = Expression.And(whereExpression, condition);
            else
                whereExpression = condition;
 
            index++;
        }
 
        Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; predicate = Expression.Lambda&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt;(whereExpression, new ParameterExpression[] { paramExpression });
        entity = table.SingleOrDefault(predicate);
    }
 
    return entity;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    
  </channel>
</rss>